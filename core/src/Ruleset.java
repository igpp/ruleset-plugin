package igpp.ruleset;

// import igpp.util.*
import igpp.util.Argument;
import igpp.util.Digest;
import igpp.util.Variable;
import igpp.util.VariableList;

// import igpp.servlet.*
import igpp.servlet.MultiPrinter;

// import java.io.*
import java.io.FileInputStream;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.io.PrintStream;

// import java.text.*
import java.text.SimpleDateFormat;

// import java.util.*
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Date;

// import igpp.util.*
// import pds.label.*;
import pds.label.PDSLabel;
import pds.label.PDSElement;
import pds.label.PDSValue;
import pds.label.PDSUtil;

/** 
 * Ruleset is a class that contains methods for parsing and running
 * rulesets and generating output which defined by the ruleset.
 * A ruleset can be defined in a file or be generated by external
 * applications. Templates are used to determine the form and structure
 * of any output generated. 
 *
 * @author      Todd King
 * @author      Planetary Data System
 * @version     1.0, 04/21/03
 * @since       1.0
 */
public class Ruleset {
	/** The list of elements in the label */
 	public ArrayList mActionList	= new ArrayList();
 	
 	/** The list of variables defined during the execution of
 	 *  a rule set
 	 **/
 	public ArrayList mVariableList	= new ArrayList();
	
 	/** The list of options defined during the execution of
 	 *  a rule set
 	 **/
 	public ArrayList mOptionList	= new ArrayList();
	
 	/** The list of global options which can be preserved and passed
 	 * by the calling application.
 	 **/
 	public ArrayList mGlobalList	= new ArrayList();
	
	/** The pathname for a text file (non-label) template */
	public String	mTemplateFile = null;
	
	/** The place where the label template is stored once loaded */
	PDSLabel	mTemplateLabel = new PDSLabel();
	
	/** Tracks which line in a file (or list) is currently being processed */
	public int mLineCount 			= 1;
	
	/** The name of the ruleset source */
	public String mSourceName		= "Unspecified";
	
	/** A flag indicating whether output should be written */
	public boolean mWriteOutput		= true;
	
	/** A flag indicating whether the processing should end */
	public boolean mAbort			= false;
	
	/** Internal map of names to IDs */
 	Argument	mOption		= new Argument();
 	
 	/** Output destination.  	 **/
 	 static public MultiPrinter mOut = new MultiPrinter(System.out);
 	 
	/** 
	 * Preserves global variables between executions of the ruleset.
	 * Used in main() and runRuleset() for command line testing.
	 **/
	 private static VariableList	mSessionList = new VariableList();
	 private static VariableList	mCommandList = new VariableList();
	 private static String		mStartPath;
	 private static String		mStartRule;
	 private static boolean		mRecurse = true;
	 
	 private static String mVersion = "1.0.1";
	 
	/** Creates an instance of a Ruleset */
 	public Ruleset() 
 	{
		/** Option names to ID map */
		mOption.add("PAD_WIDTH",	0);
		mOption.add("PAD_FILE",		0);
		mOption.add("INDENT",		0);
		mOption.add("EQUAL_AT",		0);
		mOption.add("WRAP_LINE",	0);
		mOption.add("FORCE_UPPER",	0);
		mOption.add("DEBUG",		0);

		// Initialize option values
		findAndSet(mOptionList, "PAD_WIDTH",	"80");
		findAndSet(mOptionList, "PAD_FILE",	"YES");
		findAndSet(mOptionList, "INDENT",	"2");
		findAndSet(mOptionList, "EQUAL_AT",	"32");
		findAndSet(mOptionList, "WRAP_LINE",	"80");
		findAndSet(mOptionList, "FORCE_UPPER","YES");
		findAndSet(mOptionList, "DEBUG","NO");
		findAndSet(mOptionList, "TEMPLATE",	"");
		findAndSet(mOptionList, "OUTPUT_EXT", "LBL", false);
		findAndSet(mOptionList, "OUTPUT_NAME","$FILE_PATH/$FILE_BASE.$OUTPUT_EXT", false);
 	}
 
 	/** 
	 * Loads a rule set and processes one or more files.
	 * Labeler will load a ruleset (@see Ruleset) and apply it to one or more files
	 * in a directory tree. If a directory name is passed as the starting
	 * point then the ruleset will be applied to all files in the directory
	 * and subdirectories. 
	 *<p>
	 * Options:<blockquote>
	 *    -d: Scan only the current directory. Do not recurse sub-directories.
	 *    -r: Scan the current directory and recursely scan sub-directories.
	 *</blockquote>
	 *
	 * Usage:<blockquote>
	 *     labeler ruleset [-d | -R] pathname [pathname ...]
	 * </blockquote>
	 *
	 * @param args the commandline arguments.
	 */
	public static void main(String[] args) {
		String[]	part;
		
		Ruleset ruleset = new Ruleset();
		
		System.out.println("Version: " + mVersion);
		
		// Check arguments
		if(args.length < 1) {
			System.out.println("Usage: " + ruleset.getClass().getName() + " ruleset [-d|-r] [variable=value] [pathname ...]");
			return;
		}
		
		// Process arguments
		ruleset.mStartRule = args[0];
		for(int i = 1; i < args.length; i++) {
			part = args[i].split("=", 2);
			if(part.length != 2) continue;	// Non-Assignments are skipped
			ruleset.mCommandList.findAndSet(part[0], part[1]);
		}
		
		ruleset.mStartPath = null;
		
		try {
			for(int i = 1; i < args.length; i++) {
				if(args[i].compareTo("-d") == 0) { ruleset.mRecurse = false; continue; }
				if(args[i].compareTo("-r") == 0) { ruleset.mRecurse = true; continue; }
				if(args[i].indexOf('=') != -1) continue;	// Assignments are skipped
				ruleset.mStartPath = args[i];
				if(!ruleset.processItem(ruleset.mStartRule, ruleset.mStartPath)) break;
			}
			
			if(ruleset.mStartPath == null) {	// No pathname on command line
				ruleset.processItem(ruleset.mStartRule, ruleset.mStartPath);
			}
		} catch(Exception e) {
			e.printStackTrace();
		}
	}
	
    /** 
     * Sets the writer used to output messages.
	 *
     * @param out   the output printer to use.
     *
     * @since           1.0
     */
	public void setOutput(PrintStream out) 
	{
		mOut.setOut(out);
	}
		
    /** 
     * Sets the writer used to output messages.
	 *
     * @param out   the output printer to use.
     *
     * @since           1.0
     */
	public void setOutput(PrintWriter out) 
	{
		mOut.setOut(out);
	}
		
    /** 
     * Sets the writer used to output messages.
	 *
     * @param out   the output printer to use.
     *
     * @since           1.0
     */
	public void setOutput(MultiPrinter out) 
	{
		mOut.setOut(out);
	}
		
    /** 
     * Runs a ruleset against a file system item. If the item is a directory and
     * recursion is set, then each item in the directory and below in the tree 
     * will be processed.
	 *
     * @param ruleset   the fully qualified path and name of the file containing 
     *                  the ruleset to run.
     * @param pathName  the fully qualified path and name of the file to parse.
     *
     * @return          <code>true</code> if the processing completed without errors;
     *                  <code>false</code> otherwise.
     * @since           1.0
     */
	private boolean processItem(String ruleset, String pathName) 
		throws Exception
	{
		if(pathName == null) {
			return runNewRuleset(ruleset, pathName);
		}
		
		File	item = new File(pathName);
		
		if(item.isDirectory()) {
			File[] list = item.listFiles();
			
			for(int i = 0; i < list.length; i++) {
				if(list[i].isDirectory() && mRecurse) {
					processItem(ruleset, list[i].getPath()); 
				} else { 
					if(!runNewRuleset(ruleset, list[i].getPath())) return false; 
				}
			}
			return true;
		}
		return runNewRuleset(ruleset, pathName);
		
	}
		
    /** 
     * Runs a ruleset on a single file in a new ruleset instance.
     * Saves global varaibles to the session variable
     * list so that the variables can be passed between runs of a ruleset.
	 *
     * @param ruleFile   the fully qualified path and name of the file containing 
     *                  the ruleset to run.
     * @param pathName  the fully qualified path and name of the file to parse.
     *
     * @return          <code>true</code> if the ruleset completed without errors;
     *                  <code>false</code> otherwise.
     * @since           1.0
     */
	public boolean runNewRuleset(String ruleFile, String pathName) 
		throws Exception
	{
		Ruleset ruleset = new Ruleset();

		ruleset.runRuleset(ruleFile, pathName);
				
		// Save global variables
		mSessionList.clear();
		for(int i = 0; i < ruleset.mGlobalList.size(); i++) mSessionList.findAndSet((Variable) ruleset.mGlobalList.get(i));
		
		return true;
	}

    /** 
     * Runs a ruleset on a single file. Saves global varaibles to the session variable
     * list so that the variables can be passed between runs of a ruleset.
	 *
     * @param ruleFile   the fully qualified path and name of the file containing 
     *                  the ruleset to run.
     * @param pathName  the fully qualified path and name of the file to parse.
     *
     * @return          <code>true</code> if the ruleset completed without errors;
     *                  <code>false</code> otherwise.
     * @since           1.0
     */
	public boolean runRuleset(String ruleFile, String pathName) 
		throws Exception
	{
		boolean	good = false;
		Iterator	it;
		
		// Start command line starting points
		mSessionList.findAndSet(mCommandList);
		mSessionList.findAndSet("START_RULE", mStartRule);
		mSessionList.findAndSet("START_PATH", mStartPath);
		
		// Set global variables in the ruleset processor
		it = mSessionList.iterator();
		while(it.hasNext()) { mGlobalList.add((Variable) it.next()); }
		
		if(!parse(ruleFile)) {
			showMessage(false, "An error occurred while parsing the ruleset.");
			return false;
		}
	
		// Run the ruleset
		if(!run(pathName)) {
			showMessage(false, "One or more errors occurred while processing file: " + pathName);
			showMessage(false, "No output file was created.");
			return false;
		}
		
		if(mWriteOutput) {
			if(update()) {	// Update template
				output();	// Write the template out to PPI standards
			}
		}
		
		return true;
	}
	
    /** 
     * Parses a file containing a ruleset into its constitute elments.
	 * The path and name of the file are passed to the method which is
	 * opened and parsed.
	 *
     * @param pathName  the fully qualified path and name of the file to parse.
     * @return          <code>true</code> if the file could be opened;
     *                  <code>false</code> otherwise.
     * @since           1.0
     */
 	public boolean parse(String pathName) 
 	{
		FileInputStream	file;
		String			buffer;
		BufferedReader reader;
		
		try {
			file = new FileInputStream(pathName);
			reader = new BufferedReader(new InputStreamReader(file));
		} catch(Exception e) {
			showMessage(false, "Unable to open file: " + pathName);
			return false;
		}
		
		// If we reach here file should be open and ready to parse
		findAndSet("RULE_SET", pathName);
		File path = new File(pathName);
		File absPath = new File(path.getAbsolutePath());
		findAndSet("RULE_PATH", absPath.getParent());
		mSourceName = pathName;
		while ((buffer = readLine(reader)) != null){
			if(!parseLine(buffer)) return false;
		}
		return true;
	}
	
    /** 
     * Parses a string containing a single ruleset into its constitute elments.
	 *
     * @param buffer	the line of text to parse.
     *
     * @return          <code>true</code> if the file could be opened;
     *                  <code>false</code> otherwise.
     * @since           1.0
     */
 	public boolean parseLine(String buffer) 
 	{
		boolean			status;
		String			temp;
		String			part[];
		ArrayList		list = new ArrayList();
		int				token;
		int				n;
		
		buffer = buffer.trim();
		if(buffer.length() == 0) return true;
		list.clear();
		switch(buffer.charAt(0)) {
		case '#':	// Comment
		case '/':	// Comment
			return true;
		case '<':	// Directive
			buffer = buffer.substring(1);	// Drop leading "<"
			buffer = buffer.substring(0, buffer.length()-1);	// Drop trailing ">"
			temp = argFirst(buffer);
			switch(Action.token(temp)) {
			case Action.RUN:
				list = argSplit(buffer, true);
				break;
			default:
				list = argSplit(buffer, false);
				break;
			}
				
			if(list.size() == 0) { showMessage(true, "Syntax error near: " + buffer); return false; }
			temp = (String) list.remove(0);
			token = Action.token(temp);
			switch(token) {
			case Action.NONE:
				showMessage(true, "Unknown action '" + temp + "' near: $" + buffer); 
				return false; 
			case Action.IF:
			case Action.ELSEIF:
				if(list.size() > 4)  { showMessage(true, "Syntax error near: " + buffer); return false; }
				n = list.size();
				for(int i = 0; i < n; i++) {
					list.set(i, unquote((String) list.get(i)));
				}
				break;
			}
			mActionList.add(new Action(token, list));
			break;
		case '$':	// Assignment
			buffer = buffer.substring(1);	// Drop leading "$"
			n = buffer.indexOf('=');
			if(n == -1) { showMessage(true, "Syntax error near: $" + buffer); return false; }
			list.clear();
			list.add(buffer.substring(0, n).trim());
			list.add(buffer.substring(n+1).trim());
			mActionList.add(new Action(Action.ASSIGN, list));
			break;
		default: // Syntax error
			showMessage(true, "Syntax error near: " + buffer); 
			break;
		}
		
		return true;
	}
	
    /** 
     * Run the current rule set.
     * 
	  * 
     * @param pathname	the pathname of the file to run the rule set on.
     *
     * @return          <code>true</code> if an variable was set or added;
     *                  <code>false</code> if error occured.
     *					The variable <code>mWriteOutput</output> is set to
     *					<code>true</code> if output is to be generated,
     *					<code>false</code> otherwise.
     *
     * @since           1.0
     */
	public boolean run(String pathname) 
	{
		Action	action;
		int			n;
		String		buffer;
		String		hold;
		String		dest;
		Long		value;
		Date		date;
		File		file;
		ArrayList	doBlock = new ArrayList();
		State	state;
		Ruleset	ruleset = new Ruleset();
		Variable	variable;
		Process		process;
		byte[]		stream = new byte[512];
		InputStream	input;
		Runtime		runtime;
		BufferedReader	reader;
		ArrayList	runStack = new ArrayList();
		int			level;
		ArrayList	argList;
		boolean		dontParseArg;
		String		rulePath;
		File		test;
		String		include;
		
		SimpleDateFormat dateFormatter = new SimpleDateFormat ("yyyy-MM-dd");
		SimpleDateFormat timeFormatter = new SimpleDateFormat ("yyyy-MM-dd'T'hh:mm:ss");
     
		// Parse the path name and set "system" variables
		// Full path and name
		if(pathname != null) {
			file = new File(pathname);
			
			date = new Date(file.lastModified());
			findAndSet("FILE_DATE", dateFormatter.format(date));
			findAndSet("FILE_TIME", timeFormatter.format(date));
			value = new Long(file.length());
			findAndSet("FILE_SIZE", value.toString());
			
			findAndSet("PATH_NAME", file.getPath());
			findAndSet("FILE_NAME", file.getName());
			buffer = file.getParent();
			if(buffer == null) buffer = ".";
			findAndSet("FILE_PATH", buffer);
			try {
				findAndSet("FILE_MD5", igpp.util.Digest.digestFile(pathname));
			} catch(Exception e) {
				findAndSet("FILE_MD5", "");
			}
			
			// Time values
			java.util.Date now = new java.util.Date();
			findAndSet("NOW_DATE", dateFormatter.format(now));
			findAndSet("NOW_TIME", timeFormatter.format(now));
			
			// Extension
			buffer = file.getName();
			n = buffer.lastIndexOf('.');
			if(n != -1) buffer = buffer.substring(n+1);
			else buffer = "";	// No extension
			if(getBooleanValue(mOptionList, "FORCE_UPPER") && buffer.length() > 0) buffer = buffer.toUpperCase();
			findAndSet("FILE_EXT", buffer);
			
			// Base name
			buffer = file.getName();
			if(n != -1) buffer = buffer.substring(0, n);
			if(getBooleanValue(mOptionList, "FORCE_UPPER") && buffer.length() > 0) buffer = buffer.toUpperCase();
			findAndSet("FILE_BASE", buffer);
		}

		// Now run the rule set	
		mWriteOutput = true;	
		for(int i = 0; i < mActionList.size(); i++) {
			action = (Action) mActionList.get(i);
			switch(action.mType) {
			case Action.NONE:
				break;
			case Action.OPTION:
				setOption((String) action.mArgument.get(0), replaceVariable((String) action.mArgument.get(1)));
				break;
			case Action.GLOBAL:
				findAndSet(mGlobalList, (String) action.mArgument.get(0), replaceVariable((String) action.mArgument.get(1)));
				break;
			case Action.DUMP:
				if(action.mArgument.size() == 0) buffer = "ALL";
				else buffer = (String) action.mArgument.get(0);
				if(buffer.compareToIgnoreCase("VARIABLE") == 0 || buffer.compareToIgnoreCase("ALL") == 0) {
					dumpList("Variables", mVariableList);
				}
				if(buffer.compareToIgnoreCase("OPTIONS") == 0 || buffer.compareToIgnoreCase("ALL") == 0) {
					dumpList("Options", mOptionList);
				}
				if(buffer.compareToIgnoreCase("GLOBAL") == 0 || buffer.compareToIgnoreCase("ALL") == 0) {
					dumpList("Global", mGlobalList);
				}
				break;
			case Action.OUTPUT:
				findAndSet(mOptionList, "OUTPUT_NAME", (String) action.mArgument.get(0), false);
				break;
			case Action.ASSIGN:
				findAndSet((String) action.mArgument.get(0), (String) action.mArgument.get(1));
				break;
			case Action.MESSAGE:
				for(int j = 0; j < action.mArgument.size(); j++) {
					buffer = unquote((String) action.mArgument.get(j));
					buffer = replaceVariable(buffer);
					showMessage(false, buffer);
				}
				break;
			case Action.RUN:
				buffer = "";
				try {
					// Initialize ruleset
					boolean		debug = getBooleanValue(mOptionList, "DEBUG");
					
					ruleset.reset();
					ruleset.mSourceName = "RUN";
					n = action.mArgument.size();
					if(n > 3) n = 3;	// First three at most
					for(int j = 0; j < n; j++) {
						ruleset.mSourceName += " " + (String) action.mArgument.get(j);
					}
					// Make all variables available to include
					mergeList(ruleset.mVariableList, mVariableList);
					mergeList(ruleset.mOptionList, mOptionList);
					
					// Run the command
					runtime = Runtime.getRuntime();

					// Determine how we should run application
					dontParseArg = false;
					hold = System.getProperty("os.name");
					if(hold.length() >= 6) { dontParseArg = (hold.substring(0, 6).compareToIgnoreCase("WINDOW") == 0); }
					
					// Replace variables then parse
					buffer = replaceVariable((String) action.mArgument.get(0), dontParseArg);	// The command
					for(int j = 1; j < action.mArgument.size(); j++) {
						if(buffer.length() > 0) buffer += " ";
						buffer += " " + replaceVariable((String) action.mArgument.get(j), dontParseArg);
					}
					buffer = buffer.replaceAll("\r", "\\\\r");
					buffer = buffer.replaceAll("\n", "\\\\n");

					if(debug) ruleset.showMessage(false, "Running: " + buffer);
					
					if(dontParseArg) {	// Let OS parse it
					    if(debug) ruleset.showMessage(false, "Don't parse: " + buffer);
						process = runtime.exec(buffer);
					} else {
						buffer = buffer.replaceAll("\\\\n", "\\\\\\\\n"); // Preserve escapes
						buffer = buffer.replaceAll("\\\\r", "\\\\\\\\r"); // Preserve escapes
						argList = argSplit(buffer, true);
						String[] argArray = new String[argList.size()];
						argArray = (String[]) argList.toArray(argArray);
						process = runtime.exec(argArray);
					}
					
					// Collect output from command
					ruleset.mLineCount = 0;
					input = process.getInputStream();
					reader = new BufferedReader(new InputStreamReader(input));
					while((buffer = readLine(reader)) != null) {
						ruleset.mLineCount++;
						if(debug) ruleset.showMessage(false, "   line " + ruleset.mLineCount + ": " + buffer);
						ruleset.parseLine(buffer);
					}
					// Now run the resulting ruleset
					if(!ruleset.run(pathname)) {
						return false;
					}
					
					// Take variables and merge with current variables
					mergeList(mVariableList, ruleset.mVariableList);
					mergeList(mOptionList, ruleset.mOptionList);
					
					mWriteOutput = ruleset.mWriteOutput;
					if(!mWriteOutput)	return true; 
				} catch(Exception e) {
					showMessage(false, "Unable to run: " + (String) action.mArgument.get(0));
					return false;
				}
				break;
			case Action.INCLUDE:
				include = (String) action.mArgument.get(0);
				buffer = replaceVariable(include);
				test = new File(buffer);
				rulePath = getValue("RULE_PATH");
				if(!test.exists() && rulePath != null) {	// Try adding path to current ruleset
					buffer = rulePath + test.separator + buffer;
					test = new File(buffer);
					if(!test.exists()) {
						showMessage(false, "Unable to open file: " + include);
						return false;
					}
				}
				ruleset.reset();
				if(!ruleset.parse(buffer)) {
					return false;
				}
				// Make all variables available to include
				mergeList(ruleset.mVariableList, mVariableList);
				mergeList(ruleset.mOptionList, mOptionList);
				
				// Keep state of current rule set
				hold = getValue("RULE_SET");
				ruleset.findAndSet("RULE_SET", buffer);
				
				// Now run the included rule set
				if(!ruleset.run(pathname)) {
					showMessage(false, "Failed to run include file: " + buffer);
					return false;
				}
				// Take variables and merge with current variables
				mergeList(mVariableList, ruleset.mVariableList);
				mergeList(mOptionList, ruleset.mOptionList);
				findAndSet("RULE_SET", hold);
				findAndSet("RULE_PATH", rulePath);
				
				mWriteOutput = ruleset.mWriteOutput;
				if(!mWriteOutput)	return true; 
				break;
			case Action.TEMPLATE:
				if(action.mArgument.size() != 1) break;
				buffer = (String) action.mArgument.get(0);
				buffer = replaceVariable(buffer);
				findAndSet(mOptionList, "TEMPLATE", buffer);
				break;
			case Action.IF:
				state = new State(evalCondition(action.mArgument));
				if(!state.mGood) {	// Does not match - skip to next ELSE, ELSEIF or ENDIF
					n = mActionList.size() - 1;
					i = skipBlock(i, Action.IF);
				}
				doBlock.add(state);	// Add state for this block
				break;
			case Action.ELSEIF:
				n = doBlock.size() - 1;
				if(n < 0) return false;	// Error
				state = (State) doBlock.get(n);
				if(state.mGood) {	// Previous block was executed - skip to ENDIF
					i = skipBlock(i, Action.ENDIF);
				} else {	// Previous block was not executed - check condition on this one
					state.mGood = evalCondition(action.mArgument);
					if(!state.mGood) {	// Does not match - skip to next ELSE, ELSEIF or ENDIF
						i = skipBlock(i, Action.IF);
					}
					n = doBlock.size() - 1;
					if(n >= 0) doBlock.set(n, state);	// Save state
				}
				break;
			case Action.ELSE:
				// Get state of last block
				n = doBlock.size() - 1;
				if(n < 0) return false;	// Error
				state = (State) doBlock.get(n);
				if(state.mGood) {	// Skip to ENDIF, other wise keep executing
					i = skipBlock(i, Action.ENDIF);
				}
				break;
			case Action.ENDIF:
				n = doBlock.size() - 1;
				if(n < 0) break;	// Error
				doBlock.remove(n);	// Pop off stack
				break;
			case Action.IGNORE:
				doBlock.clear();
				mWriteOutput = false;
				return true;
			case Action.ABORT:
				doBlock.clear();
				mWriteOutput = false;
				mAbort = true;
				return false;
			case Action.COPY:
				if(action.mArgument.size() < 1) break;
				buffer = (String) action.mArgument.get(0);
				buffer = replaceVariable(buffer);
				buffer = unquote(buffer);
				if(action.mArgument.size() > 1) {
					dest = (String) action.mArgument.get(1);
				} else {
					dest = getValue("FILE_PATH");
				}
				dest = replaceVariable(dest);
				dest = unquote(dest);
				try {
					igpp.util.File.copy(buffer, dest);
				} catch(Exception e) {
					showMessage(false, "Unable to copy file: " + buffer);
					showMessage(false, "   Reason: " + e.getMessage());
					return false;
				}
				break;
			case Action.MOVE:
				if(action.mArgument.size() < 1) break;
				buffer = (String) action.mArgument.get(0);
				buffer = replaceVariable(buffer);
				buffer = unquote(buffer);
				if(action.mArgument.size() > 1) {
					dest = (String) action.mArgument.get(1);
				} else {
					dest = getValue("FILE_PATH");
				}
				dest = replaceVariable(dest);
				dest = unquote(dest);
				try {
					igpp.util.File.rename(buffer, dest);
				} catch(Exception e) {
					showMessage(false, "Unable to copy file: " + buffer);
					showMessage(false, "   Reason: " + e.getMessage());
					return false;
				}
				break;
			case Action.DELETE:
				if(action.mArgument.size() < 1) break;
				buffer = (String) action.mArgument.get(0);
				buffer = replaceVariable(buffer);
				buffer = unquote(buffer);
				try {
					igpp.util.File.delete(buffer);
				} catch(Exception e) {
					showMessage(false, "Unable to copy file: " + buffer);
					showMessage(false, "   Reason: " + e.getMessage());
					return false;
				}
				break;
			case Action.MKDIR:
				if(action.mArgument.size() < 1) break;
				buffer = (String) action.mArgument.get(0);
				buffer = replaceVariable(buffer);
				buffer = unquote(buffer);
				File newDir = new File(buffer);
				if(!newDir.mkdirs()) {
					showMessage(false, "Unable to create directory: " + buffer);
					return false;
				}
				break;
			case Action.EXISTS:
				if(action.mArgument.size() < 2) break;	// needs path and variable name
				buffer = (String) action.mArgument.get(0);
				buffer = replaceVariable(buffer);
				buffer = unquote(buffer);
				File testFile = new File(buffer);
				if(testFile != null) findAndSet((String) action.mArgument.get(1), "YES");
				else findAndSet((String) action.mArgument.get(1), "");
				break;
			}
		}
		if(doBlock.size() > 0) {	// Missing endif
			showMessage(true, "At end of ruleset there were one or more missing </IF> statements.");
		}
		return true;
	}

    /** 
     * Skips a block of code. The skip can be to the next
     * executable block or an entire block set. Returns the
     * number of lines to skip in the action list.
	 * 
	 * @param start	  the line in the action list to start at.
	 * @param type      the type of skip. If set to <code>null</code> it 
	 *                  will skip the to the next block. Otherwise it 
	 *                  will skip the blockset given. Pass <code>Action.IF</code>
	 *                  to the next block in an IF block set. Pass <code>Action.ENDIF</code>
	 *                  to skip the end of the current IF block set.
	 *					the title to print for the list.
	 *
	 * @return 			the line of the next executable statement.
     *
     * @since           1.0
     */
	public int skipBlock(int start, int type) 
	{
		int		n;
		int		i;
		Action	action;
		
		i = start;
		n = mActionList.size()-1;
		while(i < n) {
			action = (Action) mActionList.get(i+1);
			if(action.mType == Action.IF) {
				i = skipBlock(i+1, Action.ENDIF);
				i++;	// Skip ENDIF
				continue;
			}
			if(type == Action.IF) {
				if(action.mType == Action.ENDIF
				|| action.mType == Action.ELSE
				|| action.mType == Action.ELSEIF) break;
				i++;
			} else if (type == Action.ENDIF) {
				if(action.mType == Action.ENDIF) break;
				i++;
			} else {	// Unknown parameter - do nothing
				break;
			}
		}
		
		return i;
	}
	
    /** 
     * Print out all items in a list.
	 * 
	 * @param title		the title to print for the list.
	 * @param list      the {@link ArrayList} containing a set of {@link Variable}
	 *					to merge with <code>dest</code>.
     *
     * @since           1.0
     */
	public void dumpList(String title, ArrayList list) 
	{
		Variable		variable;
		
		if(title != null) {
			show("-------------");
			show(title);
			show("-------------");
		}
		for(int i = 0; i < list.size(); i++) {
			variable = (Variable) list.get(i);
			show("$" + variable.mName + " = " + variable.mValue);
		}
	}
	
    /** 
     * Examines a string and returns a token representing the contents.
     * The following tokens are returned:
     *     Token     If String is
     *     !          !
     *     =          =
     *     e          exists
     *     d          isdir
     *     f          isfile
     *     $          anything else
     *
     * @param text		the string containing the text to examine
     *
     * @return          <code>token</code> representing content.
     *
     * @since           1.0
     */
	public char evalToken(String text) 
	{
		if(text.compareTo("!") == 0) return '!';
		if(text.compareTo("=") == 0) return '=';
		if(text.compareToIgnoreCase("exists") == 0) return 'e';
		if(text.compareToIgnoreCase("isdir") == 0) return 'd';
		if(text.compareToIgnoreCase("isfile") == 0) return 'f';
		
		return '$';
	}
		
    /** 
     * Evaluate a condition that is coded into a array. Returns the result of 
     * the evaluation.
	 * 
     * @param stack		the array containing the tokens for the condition 
     *					to check.
     *
     * @return          <code>true</code> if an variable was set or added;
     *                  <code>false</code> if unable to add the variable.
     *
     * @since           1.0
     */
	public boolean evalCondition(ArrayList stack) 
	{
		String		value = null;
		String		buffer;
		int			i, n;
		boolean		flip = false;
		boolean		state = false;
	
		n = stack.size();
		for(i = 0; i < n; i++) {
			buffer = (String) stack.get(i);	// Operand
			if(buffer.length() > 0) {
				switch(evalToken(buffer)) {
				case '$':	// Value
					value = replaceVariable(buffer);
					if(value == null) { state = false; break; }
					if(value.length() == 0) { state = false; break; }
					state = true;
					break;
				case '!':	// not
					flip = true;
					break;
				case '=':	// compare
					if(value == null) return false;
					
					i++;
					buffer = (String) stack.get(i);
					if(buffer.length() > 0) {
						if(buffer.charAt(0) == '=') {	// Allow for "=="
							i++;
							buffer = (String) stack.get(i);
						}
					}
					if(buffer.length() > 0) {
						if(evalToken(buffer) == '$') {
							buffer = replaceVariable(buffer);
							if(buffer == null) return false;
						}
						buffer = makeRegex(buffer);	// Convert to a regular expression
					}
					state = value.matches(buffer);
					break;
				case 'e':	// exists
					if(state == false) break;	// Syntax error
					File	file = new File(value);
					state = file.exists();			
					break;
				case 'd':	// isdir
					if(state == false) break;	// Syntax error
					File	isdir = new File(value);
					state = isdir.isDirectory();			
					break;
				case 'f':	// isfile
					if(state == false) break;	// Syntax error
					File	isfile = new File(value);
					state = isfile.isFile();			
					break;
				default:
					value = buffer;
					state = true;
					break;
				}
			}	
		}

		if(flip) {
			if(state) state = false;
			else state = true;
		}
		
		return state;
	}
	
    /** 
     * Converts a string to a regular expression pattern. All "*"
     * in the string are converted to ".*" and all "." are made
     * literal.
	 * 
     * @param pattern	the string containing "nice" tokens for wild cards.
     *
     * @return			the string altered to be a regular expression.
     *
     * @since           1.0
     */
	public String makeRegex(String pattern) 
	{
		pattern = pattern.replaceAll("\\.", "|");	// Hide for now
		pattern = pattern.replaceAll("\\*", ".*");
		pattern = pattern.replaceAll("\\|", "\\\\.");	// Make literal
		
		return pattern;
	}
    /** 
     * Prints out the current rule set in tokenized form.
	 * 
     * @param doAction	the type of list to dump. If true then the
     * 					action list will be dumped, otherwise the variable
     *					list will be dumped.
     *
     * @since           1.0
     */
	public void dump(boolean doAction) 
	{
		if(doAction) {
			Action	action;
			for(int i = 0; i < mActionList.size(); i++) {
				action = (Action) mActionList.get(i);
				action.dump();
			}
		} else {	// Dump variables
			Variable	variable;
			for(int i = 0; i < mVariableList.size(); i++) {
				variable = (Variable) mVariableList.get(i);
				variable.dump();
			}
		}
	}
	
    /** 
     * Extract the first argument in the string. This is the text up the
     * first whitespace delimiter.
	 * 
     * @param buffer	the string to parse.
     *
     * @return          <code>String</code> containing the first argument.
     *
     * @since           1.0
     */
     
	public String argFirst(String buffer) 
	{
		int			n;
		char		c;
		String		temp = "";
		boolean		inQuote = false;
		
		n = buffer.length();
		for(int i = 0; i < n; i++) {
			c = buffer.charAt(i);
			if(c == '"') { if(inQuote) inQuote = false; else inQuote = true; }
			if(inQuote) {
				temp += c;
			} else {
				if(Character.isWhitespace(c)) {	// Argument seperator
					if(temp.length() > 0) { return temp; }
				} else {
					temp += c;
				}
			}
		}
		
		return temp;
	}
	
    /** 
     * Split a string into one or more substrings by parsing on
     * whitespace and treating "!" and "=" as individual arguments. 
     * Arguments in quotes are kept intack. Escaped characters are
     * converted preserved with the escape removed.
	 * 
     * @param buffer	the string to parse.
     * @param onlyWhitespace	if <code>true</code> split the string 
     *					using only whitespace as a delimiter. If <code>false</code>
     *					the string is parsed on whitespace and "!" and "=" 
     *					are considered as individual arguments.
     *
     * @return          <code>ArrayList</code> an array of arguments.
     *
     * @since           1.0
     */
	public ArrayList argSplit(String buffer, boolean onlyWhitespace) 
	{
		ArrayList	arg = new ArrayList();
		int			n;
		char		c;
		String		temp = "";
		boolean		inQuote = false;
		
		n = buffer.length();
		for(int i = 0; i < n; i++) {
			c = buffer.charAt(i);
			if(c == '\\') { // Convert escaped characters
			  i++; 
			  if(i < n) {temp += buffer.charAt(i);} 
		    } else {
				if(c == '"') { if(inQuote) inQuote = false; else inQuote = true; }
				if(inQuote) {
					temp += c;
				} else {
					if(onlyWhitespace) {
						if(Character.isWhitespace(c)) {	// Argument seperator
							if(temp.length() > 0) { arg.add(temp); temp = ""; }
						} else {
							temp += c;
						}
					} else {	// Use all tokens 
						if(Character.isWhitespace(c)) {	// Argument seperator
							if(temp.length() > 0) { arg.add(temp); temp = ""; }
						} else if(c == '!') {	// Seperator
							if(temp.length() > 0) { arg.add(temp); }
							arg.add("!"); 
							temp = "";
						} else if(c == '=') {	// Seperator
							if(temp.length() > 0) { arg.add(temp); }
							arg.add("="); 
							temp = "";
						} else {	// Add to buffer
							temp += c;
						}
					}
				}
			}
		}
		if(temp.length() > 0) { arg.add(temp); temp = ""; }
		
		return arg;
	}
	
    /** 
     * Converts a string to a boolean state. If the string contains
     * "YES" then the state returned is <code>true</code>. If it
     * is anything else then <code>false</code> is returned.
	 * 
     * @param value		the string to convert.
     *
     * @return          <code>true</code> if the string is "YES";
     *                  <code>false</code> if string is anything else.
     *
     * @since           1.0
     */
	public boolean convertYesNo(String value) 
	{
		if(value.compareToIgnoreCase("YES") == 0) return true;
		if(value.compareToIgnoreCase("TRUE") == 0) return true;
		if(value.compareToIgnoreCase("1") == 0) return true;
		return false;
	}
	
    /** 
     * Sets the value of an option.
	 * 
     * @param name		the name of the variable to set.
     * @param value		the value to set for the variable.
     *
     * @since           1.0
     */
	public void setOption(String name, String value) 
	{
		if(mOption.token(name) == -1) {
			showMessage(true, "Unknown option: " + name);
		} else {	// Set option
			findAndSet(mOptionList, name, value);
		}
	}
	
	/** 
     * Set variable list to match a passed list.
	 * 
	 * @param dest      the {@link ArrayList} to merge the contents of 
	 *					<code>list</code> to.
	 * @param list      the {@link ArrayList} containing a set of {@link Variable}
	 *					to merge with <code>dest</code>.
     *
     * @since           1.0
     */
	public void mergeList(ArrayList dest, ArrayList list) 
	{
		int		n;
		Variable	variable;
		
		n = list.size();
		for(int j = 0; j < n; j++) {
			variable = (Variable) list.get(j);
			findAndSet(dest, variable);
		}
	}
	
	/** 
     * Finds a variable in the variable list and set its value.
     * If the variable does not exist one is added.
	 * 
     * @param variable	the name of the variable to set.
     *
     * @return          <code>true</code> if an variable was set or added;
     *                  <code>false</code> if unable to add the variable.
     *
     * @since           1.0
     */
	public boolean findAndSet(Variable variable) 
	{
		return findAndSet(variable.mName, variable.mValue);
	}
	
	/** 
     * Finds a variable in the variable list and set its value.
     * If the variable does not exist one is added.
	 * 
	 * @param list      the {@link ArrayList} containing a set of {@link Variable}
	 *					to merge with <code>dest</code>.
     * @param variable	the name of the variable to set.
     *
     * @return          <code>true</code> if an variable was set or added;
     *                  <code>false</code> if unable to add the variable.
     *
     * @since           1.0
     */
	public boolean findAndSet(ArrayList list, Variable variable) 
	{
		return findAndSet(list, variable.mName, variable.mValue, false);
	}
	
    /** 
     * Finds an item in an array list and set its value.
     * If the item does not exist one is added.
	 * 
     * @param name		the name of the variable to set.
     * @param value		the value to set for the variable.
     *
     * @return          <code>true</code> if an variable was set or added;
     *                  <code>false</code> if unable to add the variable.
     *
     * @since           1.0
     */
	public boolean findAndSet(String name, String value) 
	{
		return findAndSet(name, value, true);
	}
	
    /** 
     * Finds an item in an array list and set its value.
     * If the item does not exist one is added.
	 * 
	 * @param list      the {@link ArrayList} containing a set of {@link Variable}
	 *					to merge with <code>dest</code>.
     * @param name		the name of the variable to set.
     * @param value		the value to set for the variable.
     *
     * @return          <code>true</code> if an variable was set or added;
     *                  <code>false</code> if unable to add the variable.
     *
     * @since           1.0
     */
	public boolean findAndSet(ArrayList list, String name, String value) 
	{
		return findAndSet(list, name, value, true);
	}
	
    /** 
     * Finds an item in an array list and set its value.
     * If the item does not exist one is added.
	 * 
     * @param name		the name of the variable to set.
     * @param value		the value to set for the variable.
     * @param resolve	a flag indicating whether to resolve variables in the
     *					value. 
     *
     * @return          <code>true</code> if an variable was set or added;
     *                  <code>false</code> if unable to add the variable.
     *
     * @since           1.0
     */
	public boolean findAndSet(String name, String value, boolean resolve) {
		return findAndSet(mVariableList, name, value, resolve);
	}
	
    /** 
     * Finds an item in an array list and set its value.
     * If the item does not exist one is added.
	 * 
	 * @param list      the {@link ArrayList} containing a set of {@link Variable}
	 *					to merge with <code>dest</code>.
     * @param name		the name of the variable to set.
     * @param value		the value to set for the variable.
     * @param resolve	a flag indicating whether to resolve variables in the
     *					value. 
     *
     * @return          <code>true</code> if an variable was set or added;
     *                  <code>false</code> if unable to add the variable.
     *
     * @since           1.0
     */
	public boolean findAndSet(ArrayList list, String name, String value, boolean resolve) 
	{
		Variable		variable;
		
		// Clean-up and unquote value
		if(value != null) {
			value = value.trim();
			if(value.startsWith("\"")) value = value.substring(1);
			if(value.endsWith("\"")) value = value.substring(0, value.length()-1);
		}
		
		// Replace variables - if needed
		if(resolve) value = replaceVariable(value);
		
		// Search for variable
		for(int i = 0; i < list.size(); i++) {
			variable = (Variable) list.get(i);
			if(variable.mName.compareTo(name) == 0) {
				variable.mValue = value;
				return true;
			}
		}
		
		// If we reach here we need to define the variable
		list.add(new Variable(name, value));
		return true;	
	}
	
    /** 
     * Finds a variable in the variable list and returns its value.
     * If the variable does not exist null is returned.
	 * 
     * @param name		the name of the variable to set.
     *
     * @return          <code>null</code> if an variable does not exist;
     *                  the value assigned to the variable if it does.
     *
     * @since           1.0
     */
	public String getValue(String name) 
	{
		String	value;
		
		value = getValue(mVariableList, name, false);
		if(value == null) value = getValue(mGlobalList, name, false);
		if(value == null) value = getValue(mOptionList, name, false);
		
		return value;
	}	
	
    /** 
     * Finds a variable in the variable list and returns its value.
     * If the variable does not exist null is returned.
	 * 
	 * @param list      the {@link ArrayList} containing a set of {@link Variable}
	 *					to merge with <code>dest</code>.
     * @param name		the name of the variable to set.
     * @param blank		indicates whether to return a blank string if 
     *					the variable is not found. If <code>true</code> a
     *					blank is returned. Otherwise <code>null</code> is returned.
     *
     * @return          The variable <code>null</code> if a variable does not exist and
     *					<code>blank</code> is <code>false</code>. Returns a blank string
     *					if <code>blank</code> is true;
     *                  the value assigned to the variable if it does.
     *
     * @since           1.0
     */
	public String getValue(ArrayList list, String name, boolean blank) 
	{
		Variable		variable;
		
		for(int i = 0; i < list.size(); i++) {
			variable = (Variable) list.get(i);
			if(variable.mName.compareTo(name) == 0) {
				return variable.mValue;
			}
		}
		
		if(blank) return "";
		
		return null;
	}
	
    /** 
     * Finds an item in a variable list and returns its value as an integer.
     * If the variable does not exist 0 is returned. Since 0 is a valid integer
     * it can not be considered and indication that a variable does not exist.
	 * 
	 * @param list      the {@link ArrayList} containing a set of {@link Variable}
	 *					to merge with <code>dest</code>.
     * @param name		the name of the variable to set.
     *
     * @return          integer value assigned to the variable.
     *
     * @since           1.0
     */
	public int getIntValue(ArrayList list, String name) 
	{
		String	buffer;
		
		buffer = getValue(list, name, true);
		return Integer.parseInt(buffer);
	}
	
    /** 
     * Finds an item in a variable list and returns its value as an boolean.
     * If the variable does not exist false is returned. 
	 * 
	 * @param list      the {@link ArrayList} containing a set of {@link Variable}
	 *					to merge with <code>dest</code>.
     * @param name		the name of the variable to set.
     *
     * @return          boolean value assigned to the variable.
     *
     * @since           1.0
     */
	public boolean getBooleanValue(ArrayList list, String name) 
	{
		String	buffer;
		
		buffer = getValue(list, name, true);
		return convertYesNo(buffer);
	}
	
    /** 
     * Extracts the extension from a file name and returns the extension in uppercase.
	 * 
     * @param name		the name of the file.
     *
     * @return          String containing the extension in uppercase.
     *
     * @since           1.0
     */
	public String getExtension(String name) {
		String	ext;
		int	n;
		
		n = name.lastIndexOf(".");
		if(n == -1) return "";
		
		ext = name.substring(n+1);
		ext = ext.toUpperCase();
		
		return ext;
	}
	
    /** 
     * Determines if the extension of a file name matches a given string.
	 * 
     * @param name		the name of the file.
     * @param extension		the extension to check for.
     *
     * @return          boolean value of true if the extension is the same as the string.
     *
     * @since           1.0
     */
	public boolean isExtension(String name, String extension) 
	{
		String	ext;
		
		ext = getExtension(name);
		if(ext.compareToIgnoreCase(extension) == 0) return true;
		
		return false;
	}
	
    /** 
     * Parses the next line from a {@link BufferedReader} stream. A logical line
	 * can span multiple physical lines when quotes (") or tag
	 * delimiters (<>) are used.
	 * 
     * @param stream    the opened and ready input file stream
     *
     * @return          <code>true</code> if an element was parsed from the stream;
     *                  <code>false</code> if the end of file or an error was encountered.
     */
	public String readLine(BufferedReader stream) 
	{
		int			lastC = 0;
		int			c = 0;
		int			quote = ' ';
		boolean		inQuote = false;
		boolean		inBlock = false;
		boolean		inComment = false;
		boolean		inUnits = false;
		String		buffer;
		
		mLineCount = 0;
		buffer = "";
		try {
			while((c = stream.read()) != -1) {
				buffer += (char) c;
				if(c == '\n') mLineCount++;
				if(!inComment) {	// Check for quoting
					if(c == '"') { if(inQuote) inQuote = false; else inQuote = true; }
				}
				if(!inQuote) {	// Check if in comment
					if(lastC == '/' && c == '*') inComment = true;
					if(lastC == '*' && c == '/') inComment = false;
				}
				lastC = c;
				if(inQuote) continue;
				if(inComment) continue;
				
				if(c == '\'') { if(inBlock) inBlock = false; else inBlock = true; }
				if(c == '(' || c == '{') { if(inBlock) { showMessage(true, "Syntax error near: " + buffer); } inBlock = true; }
				if(c == ')' || c == '}') { if(!inBlock) { showMessage(true, "Syntax error near: " + buffer); } inBlock = false; }
				if(c == '<') { if(inUnits) { showMessage(true, "Syntax error near: " + buffer); } inUnits = true; }
				if(c == '>') { if(!inUnits) { showMessage(true, "Syntax error near: " + buffer); } inUnits = false; }
				
				if(c == '\n' && !inQuote && !inBlock && !inUnits) break;
			}
		} catch(Exception e) {
			return null;
		}
		if(c == -1 && buffer.length() == 0) return null;	// End of file
		
		return buffer;
	}
	
    /** 
     * Clear all variables, rules and states in the ruleset.
     */
	public void reset() 
	{
		mVariableList.clear();
		mActionList.clear();
		mTemplateLabel.reset();
		mTemplateFile = null;
	}
		
    /** 
     * Searches the passed string for variables and replaces each 
     * variable with its current value. The string is passed through
     * only once.
     *
     * @param buffer	the string to search for variables.
     *
     * @return			the string with all variables replaced with
     *					the current value.
     */
	public String replaceVariable(String buffer) {
		return replaceVariable(buffer, true);
	}
	
    /** 
     * Searches the passed string for variables and replaces each 
     * variable with its current value. The string is passed through
     * only once. Variable can have quotations escaped.
     *
     * @param buffer	the string to search for variables.
     * @param plain		if true then values are taken as is (plain) otherwise
     *                  quote marks (") are escaped.
     * @return			the string with all variables replaced with
     *					the current value.
     */
	public String replaceVariable(String buffer, boolean plain) 
	{
		String 	output = "";
		String	name;
		String	value;
		int		start = 0;
		int		i, n;
		int		len;
		char	c;
		
		if(buffer == null) return buffer;
		len = buffer.length();
		
		while((n = buffer.indexOf('$', start)) != -1) {
			if(n > start) output += buffer.substring(start, n);
			n++;
			name = "";
			while(n < len) {	// Get variable name
				c = (char) buffer.charAt(n);
				if(!Character.isLetterOrDigit(c) && c != '_') break;
				name += c;
				n++;
			}
			// Find variable - if not found in variable list - check option list
			value = getValue(mVariableList, name, false);
			if(value == null) value = getValue(mGlobalList, name, false);
			if(value == null) value = getValue(mOptionList, name, true);
			if(!plain) {	// Escape the quotation marks
			   value = value.replaceAll("\"", "\\\"");
			}
			output += value;
			start = n;
		}
		if(start < len) output += buffer.substring(start, len);
		
		return output;
	}
		
    /** 
     * Prints and error message to the display. Adds information to the
     * message to help identify where the error occurred.
	 * 
	 * @param location	indicates whether location information should be
	 *					displayed before the message.
	 * @param message	the text of the message to display.
	 *
     * @since           1.0
     */
	public void showMessage(boolean location, String message) 
	{
		if(location) {
			show("Line: " + mLineCount + "; Source: " + mSourceName);
			show("\t");
		}
		show(message);
	}
	
    /** 
     * Prints text to the display. 
     *
     * @param message	the text of the message to display.
	 *
     * @since           1.0
     */
	static public void show(String message) 
	{
		try {
			mOut.println(message);
		} catch(Exception e) {
		}
	}
	
    /** 
     * Prints text to the display. May be used for rules that require only one argument.
     *
     * @param type		the type of rule to create. See {@link Action} for valid types.
	 *
     * @since           1.0
     */
	static public void showRule(int type) 
	{
		String	message;
		
		message = makeRule(type, null, null);
		show(message);
	}
	
    /** 
     * Prints text to the display. May be used for rules that require only one argument.
     *
     * @param type		the type of rule to create. See {@link Action} for valid types.
     * @param arg1		the first argument for the rule. If argument is not
     *					set pass <code>null</code>.
	 *
     * @since           1.0
     */
	static public void showRule(int type, String arg1) {
		String	message;
		
		message = makeRule(type, arg1, null);
		show(message);
	}
	
    /** 
     * Prints text to the display. Used for rules which require multiple arguments.
     * If an argument is not defined or not required pass <code>null</code> as the
     * value. 
     *
     * @param type		the type of rule to create. See {@link Action} for valid types.
     * @param arg1		the first argument for the rule. If argument is not
     *					set pass <code>null</code>.
     * @param arg2		the second argument for the rule. If argument is not
     *					set pass <code>null</code>.
	 *
     * @since           1.0
     */
	static public void showRule(int type, String arg1, String arg2) 
	{
		String	message;
		
		message = makeRule(type, arg1, arg2);
		show(message);
	}
	
    /** 
     * Prints text to the display. Used for rules which require multiple arguments.
     * If an argument is not defined or not required pass <code>null</code> as the
     * value. 
     *
     * @param type		the type of rule to create. See {@link Action} for valid types.
     * @param arg1		the first argument for the rule. If argument is not
     *					set pass <code>null</code>.
     * @param arg2		the second argument for the rule. If argument is not
     *					set pass <code>null</code>.
	 *
     * @since           1.0
     */
	static public void showRule(int type, String arg1, int arg2) 
	{
		String	message;
		
		message = makeRule(type, arg1, Integer.toString(arg2));
		show(message);
	}
	
    /** 
     * Prints text to the display. Used for rules which require multiple arguments.
     * If an argument is not defined or not required pass <code>null</code> as the
     * value. 
     *
     * @param type		the type of rule to create. See {@link Action} for valid types.
     * @param arg1		the first argument for the rule. If argument is not
     *					set pass <code>null</code>.
     * @param arg2		the second argument for the rule. If argument is not
     *					set pass <code>null</code>.
	 *
     * @since           1.0
     */
	static public void showRule(int type, String arg1, double arg2) {
		String	message;
		
		message = makeRule(type, arg1, Double.toString(arg2));
		show(message);
	}
	
    /** 
     * Update the current template by replacing all variables
     * with the defined values. The template is a PDS label
     * and only the values assigned to an element may contain
     * variables.
	 * 
     * @since           1.0
     */
	public boolean update() 
	{
		PDSElement	element;
		PDSValue	value;
		String		buffer;
		
		buffer = getValue(mOptionList, "TEMPLATE", false);
		if(buffer == null || buffer.length() == 0) {
			showMessage(false, "Template file not defined.");
			return false;
		}
		
		// Clear tempalte settings
		mTemplateFile = null;
		mTemplateLabel.reset();
		
		// Use extension to determine template type
		if(isExtension(buffer, "lbl")) {
			try {
				mTemplateLabel.parse(buffer);
			} catch (Exception e) {
				showMessage(false, "Unable to open template file: " + buffer);
				showMessage(false, e.getMessage());
				return false;
			}
	
			if(mTemplateLabel.mElement.size() == 0) {
				showMessage(true, "Template is empty.");
			}
			for(int i = 0; i < mTemplateLabel.mElement.size(); i++) {
				element = (PDSElement) mTemplateLabel.mElement.get(i);
				for(int j = 0; j < element.mValue.size(); j++) {
					value = (PDSValue) element.mValue.get(j);
					value.mValue = replaceVariable(value.mValue);
				}
				
				// Now reparse the value
				if(element.mKeyword.compareTo("END") != 0 
				&& element.mType != PDSElement.TYPE_COMMENT
				&& element.mType != PDSElement.TYPE_BLANK_LINE) {	// Not an END statement
					buffer = element.valueString();
					try {
						element.parseValue(buffer);
					} catch (Exception e) {
						showMessage(false, "Invalid value assigned to: " + element.mKeyword);
					}
				}
			}
		} else {	// Non-label (text) file
			mTemplateFile = buffer;
			findAndSet(mOptionList, "OUTPUT_EXT", getExtension(mTemplateFile), false);	// Use extension of template
		}
		return true;
	}
	
    /** 
     * Writes the template to the output files. The name and format
     * for the output file is controlled by various global options.
     * 
     * @since           1.0
     */
	public void output() 
		throws Exception
	{
		String	outputName;
	
		outputName = replaceVariable(getValue(mOptionList, "OUTPUT_NAME", true));
		if(getBooleanValue(mOptionList, "FORCE_UPPER")) outputName = outputName.toUpperCase();
		if(outputName.length() == 0) {
			showMessage(false, "Output file name is empty. Invalid file name for output.");
			return;
		} 
		
		if(mTemplateFile != null) {	// Its an text file
			String	buffer;
			FileInputStream input = new FileInputStream(mTemplateFile);
			BufferedReader reader = new BufferedReader(new InputStreamReader(input));
			
			PrintWriter	writer = null;
			FileOutputStream output = null;
			
			if(outputName.compareTo("-") == 0) {	// Write to standard out
				writer = new PrintWriter(System.out);
			} else {	// Open file 
				output = new FileOutputStream(outputName);
				writer = new PrintWriter(output);
			}
			
			while((buffer = reader.readLine()) != null) {
				buffer = replaceVariable(buffer, true);
				writer.println(buffer);
			}
			writer.close();
			if(output != null) output.close();
			reader.close();
			input.close();
		} else {	// Its a label
			int		indent;
			int		equalAt;
			int		padWidth;
			indent = getIntValue(mOptionList, "INDENT");
			equalAt = getIntValue(mOptionList, "EQUAL_AT");
			mTemplateLabel.print(outputName, indent, equalAt);
			if(getBooleanValue(mOptionList, "PAD_FILE")) {
				padWidth = getIntValue(mOptionList, "PAD_WIDTH");
				PDSUtil util = new PDSUtil();
				util.padFile(outputName, padWidth);
			}
		}
	}
	
    /** 
     * Removes quotes from a string if the string starts with and ends with
     * a quote character (").
     * 
     * @param buffer	the string to remove the quotes from.
     *
     * @return 			the string with the quotes removed, or the
     *					orginal string of it is not quoted.
     *
     * @since           1.0
     */
	static public String unquote(String buffer) {
		String	result;

		if(buffer.startsWith("\"") && buffer.endsWith("\"")) {
			result = buffer.substring(1, buffer.length() - 1);
		} else {
			result = buffer;
		}
		
		return result;
	}
	
    /** 
     * Creates a syntactically correct rule with the parameters passed.
     * 
     * @param type		the type of rule to create. See {@link Action} for valid types.
     * @param arg1		the first argument for the rule. If argument is not
     *					set pass <code>null</code>.
     * @param arg2		the second argument for the rule. If argument is not
     *					set pass <code>null</code>.
     *
     * @return 			the string with the fully formed rule or <code>null</code>
     *					if the type is unknown.
     *
     * @since           1.0
     */
	static public String makeRule(int type, String arg1, String arg2) {
		String	buffer = null;
		String	error = new String("Invalid calling of PPIRule.makeRule()");

		switch(type) {
		case Action.COPY:
			if(arg1 == null) buffer = makeRule(Action.MESSAGE, error, null);
			if(arg2 == null) buffer = "<COPY " + arg1 + ">";
			else buffer = "<COPY " + arg1 + " " + arg2 + ">";
			break;
		case Action.MOVE:
			if(arg1 == null || arg2 == null) buffer = makeRule(Action.MESSAGE, error, null);
			else buffer = "<MOVE " + arg1 + " " + arg2 + ">";
			break;
		case Action.DELETE:
			if(arg1 == null) buffer = makeRule(Action.MESSAGE, error, null);
			else buffer = "<DELETE " + arg1 + ">";
			break;
		case Action.OPTION:
			if(arg1 == null || arg2 == null) buffer = makeRule(Action.MESSAGE, error, null);
			else buffer = "<OPTION " + arg1 + " " + arg2 + ">";
			break;
		case Action.OUTPUT:
			if(arg1 == null) buffer = makeRule(Action.MESSAGE, error, null);
			else buffer = "<OUTPUT \"" + arg1 + "\">";
			break;
		case Action.ASSIGN:
			if(arg1 == null || arg2 == null) buffer = makeRule(Action.MESSAGE, error, null);
			else buffer = "$" + arg1 + " = \"" + arg2 + "\"";
			break;
		case Action.MESSAGE:
			if(arg1 == null) buffer = makeRule(Action.MESSAGE, error, null);
			else buffer = "<MESSAGE \"" + arg1 + "\">";
			break;
		case Action.RUN:
			if(arg1 == null || arg2 == null) buffer = makeRule(Action.MESSAGE, error, null);
			else buffer = "<OPTION " + arg1 + " " + arg2 + ">";
			break;
		case Action.INCLUDE:
			if(arg1 == null ) buffer = makeRule(Action.MESSAGE, error, null);
			else buffer = "<INCLUDE " + arg1 + ">";
			break;
		case Action.TEMPLATE:
			if(arg1 == null) buffer = makeRule(Action.MESSAGE, error, null);
			else buffer = "<TEMPLATE " + arg1 + " " + arg2 + ">";
			break;
		case Action.IF:
			if(arg1 == null || arg2 == null) buffer = makeRule(Action.MESSAGE, error, null);
			else buffer = "<IF " + arg1 + " = " + arg2 + ">";
			break;
		case Action.ELSEIF:
			if(arg1 == null || arg2 == null) buffer = makeRule(Action.MESSAGE, error, null);
			else buffer = "<ELSEIF " + arg1 + " = " + arg2 + ">";
			break;
		case Action.ELSE:
			buffer = "<ELSE>";
			break;
		case Action.ENDIF:
			buffer = "<ENDIF>";
			break;
		case Action.IGNORE:
			buffer = "<IGNORE>";
			break;
		case Action.ABORT:
			buffer = "<ABORT>";
			break;
		case Action.GLOBAL:
			if(arg1 == null || arg2 == null) buffer = makeRule(Action.MESSAGE, error, null);
			else buffer = "<GLOBAL " + arg1 + " " + arg2 + ">";
			break;
		}
		
		return buffer;
	}
}